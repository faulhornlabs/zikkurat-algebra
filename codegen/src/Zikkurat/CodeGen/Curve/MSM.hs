
-- | Multi-Scalar Multiplication

{-# LANGUAGE StrictData, RecordWildCards #-}
module Zikkurat.CodeGen.Curve.MSM where

--------------------------------------------------------------------------------

import Data.List
import Data.Word
import Data.Bits

import Control.Monad
import System.FilePath

import Zikkurat.CodeGen.Misc
--import Zikkurat.Primes -- ( integerLog2 )

import Zikkurat.CodeGen.Curve.Params
import Zikkurat.CodeGen.Curve.CurveFFI

--------------------------------------------------------------------------------

msm_c_header :: CodeGenParams -> Code
msm_c_header (CodeGenParams{..}) =
  [ "extern void " ++ prefix ++ "MSM_std_coeff_"    ++ point_repr ++ "_out(int npoints, const uint64_t *expos, const uint64_t *grps, uint64_t *tgt, int expo_nlimbs);"
  , "extern void " ++ prefix ++ "MSM_mont_coeff_"   ++ point_repr ++ "_out(int npoints, const uint64_t *expos, const uint64_t *grps, uint64_t *tgt, int expo_nlimbs);"
  , "extern void " ++ prefix ++ "MSM_binary_coeff_" ++ point_repr ++ "_out(int npoints, const uint8_t  *expos, const uint64_t *grps, uint64_t *tgt);"
  , "extern void " ++ prefix ++ "MSM_std_coeff_affine_out   (int npoints, const uint64_t *expos, const uint64_t *grps, uint64_t *tgt, int expo_nlimbs);"
  , "extern void " ++ prefix ++ "MSM_mont_coeff_affine_out  (int npoints, const uint64_t *expos, const uint64_t *grps, uint64_t *tgt, int expo_nlimbs);"
  , "extern void " ++ prefix ++ "MSM_binary_coeff_affine_out(int npoints, const uint8_t  *expos, const uint64_t *grps, uint64_t *tgt);"
  , ""
  , "extern void " ++ prefix ++ "MSM_std_coeff_" ++ point_repr ++ "c_out_slow_reference(int npoints, const uint64_t *expos, const uint64_t *grps, uint64_t *tgt, int expo_nlimbs);"
  , ""
  , "extern void " ++ prefix ++ "multi_MSM_binary_coeff_" ++ point_repr ++ "_out(int nrows, int npoints, const uint8_t **expos, const uint64_t *grps, uint64_t *tgt);"
  , "extern void " ++ prefix ++ "multi_MSM_binary_coeff_affine_out(int nrows, int npoints, const uint8_t **expos, const uint64_t *grps, uint64_t *tgt);"
  ]

msm_hs_binding :: CodeGenParams -> Code
msm_hs_binding (CodeGenParams{..}) =
  [ ""
  , "foreign import ccall unsafe \"" ++ prefix ++ "MSM_std_coeff_"     ++ point_repr ++ "_out\" c_" ++ prefix ++ "MSM_std_coeff_"    ++ point_repr ++ "_out :: CInt -> Ptr Word64 -> Ptr Word64 -> Ptr Word64 -> CInt -> IO ()"
  , "foreign import ccall unsafe \"" ++ prefix ++ "MSM_mont_coeff_"    ++ point_repr ++ "_out\" c_" ++ prefix ++ "MSM_mont_coeff_"   ++ point_repr ++ "_out :: CInt -> Ptr Word64 -> Ptr Word64 -> Ptr Word64 -> CInt -> IO ()"
  , "foreign import ccall unsafe \"" ++ prefix ++ "MSM_binary_coeff_"  ++ point_repr ++ "_out\" c_" ++ prefix ++ "MSM_binary_coeff_" ++ point_repr ++ "_out :: CInt -> Ptr Word8  -> Ptr Word64 -> Ptr Word64 -> IO ()"
  , ""
  , "foreign import ccall unsafe \"" ++ prefix ++ "multi_MSM_binary_coeff_" ++ point_repr ++ "_out\" c_" ++ prefix ++ "multi_MSM_binary_coeff_" ++ point_repr ++ "_out :: CInt -> CInt -> Ptr (Ptr Word8) -> Ptr Word64 -> Ptr Word64 -> IO ()"
  , "foreign import ccall unsafe \"" ++ prefix ++ "multi_MSM_binary_coeff_affine"         ++ "_out\" c_" ++ prefix ++ "multi_MSM_binary_coeff_affine"         ++ "_out :: CInt -> CInt -> Ptr (Ptr Word8) -> Ptr Word64 -> Ptr Word64 -> IO ()"
  , ""
  , "{-# NOINLINE msm #-}"
  , "-- | Multi-Scalar Multiplication (MSM), with the coefficients in Montgomery representation,"
  , "-- and the curve points in affine coordinates"
  , "-- "
  , "-- > msm :: FlatArray Fr -> FlatArray Affine.G1 -> G1"
  , "-- "
  , "msm :: FlatArray Fr -> FlatArray " ++ hsModule hs_path_affine ++ "." ++ typeName ++ " -> " ++ typeName
  , "msm (MkFlatArray n1 fptr1) (MkFlatArray n2 fptr2)"
  , "  | n1 /= n2   = error \"msm: incompatible array dimensions\""
  , "  | otherwise  = unsafePerformIO $ do"
  , "      fptr3 <- mallocForeignPtrArray " ++ show (3*nlimbs_p)
  , "      withForeignPtr fptr1 $ \\ptr1 -> do"
  , "        withForeignPtr fptr2 $ \\ptr2 -> do"
  , "          withForeignPtr fptr3 $ \\ptr3 -> do"
  , "            c_" ++ prefix ++ "MSM_mont_coeff_" ++ point_repr ++ "_out (fromIntegral n1) ptr1 ptr2 ptr3 " ++ show nlimbs_r
  , "      return (Mk" ++ typeName ++ " fptr3)"
  , ""
  , "{-# NOINLINE msmStd #-}"
  , "-- | Multi-Scalar Multiplication (MSM), with the coefficients in standard representation,"
  , "-- and the curve points in affine coordinates"
  , "-- "
  , "-- > msmStd :: FlatArray Std.Fr -> FlatArray Affine.G1 -> G1"
  , "-- "
  , "msmStd :: FlatArray " ++ hsModule hs_path_r_std ++ ".Fr -> FlatArray " ++ hsModule hs_path_affine ++ "." ++ typeName ++ " -> " ++ typeName
  , "msmStd (MkFlatArray n1 fptr1) (MkFlatArray n2 fptr2)" 
  , "  | n1 /= n2   = error \"msmStd: incompatible array dimensions\""
  , "  | otherwise  = unsafePerformIO $ do"
  , "      fptr3 <- mallocForeignPtrArray " ++ show (3*nlimbs_p)
  , "      withForeignPtr fptr1 $ \\ptr1 -> do"
  , "        withForeignPtr fptr2 $ \\ptr2 -> do"
  , "          withForeignPtr fptr3 $ \\ptr3 -> do"
  , "            c_" ++ prefix ++ "MSM_std_coeff_" ++ point_repr ++ "_out (fromIntegral n1) ptr1 ptr2 ptr3 " ++ show nlimbs_r
  , "      return (Mk" ++ typeName ++ " fptr3)"
  , ""
  , "{-# NOINLINE msmBinary #-}"
  , "-- | Multi-Scalar Multiplication (MSM), with binary coefficients,"
  , "-- and the curve points in affine coordinates"
  , "-- "
  , "-- > msmBinary :: FlatArray Bit -> FlatArray Affine.G1 -> G1"
  , "-- "
  , "msmBinary :: FlatArray L.Bit -> FlatArray " ++ hsModule hs_path_affine ++ "." ++ typeName ++ " -> " ++ typeName
  , "msmBinary (MkFlatArray n1 fptr1) (MkFlatArray n2 fptr2)"
  , "  | n1 /= n2   = error \"msmBinary: incompatible array dimensions\""
  , "  | otherwise  = unsafePerformIO $ do"
  , "      fptr3 <- mallocForeignPtrArray " ++ show (3*nlimbs_p)
  , "      withForeignPtr fptr1 $ \\ptr1 -> do"
  , "        withForeignPtr fptr2 $ \\ptr2 -> do"
  , "          withForeignPtr fptr3 $ \\ptr3 -> do"
  , "            c_" ++ prefix ++ "MSM_binary_coeff_" ++ point_repr ++ "_out (fromIntegral n1) (castPtr ptr1) ptr2 ptr3" 
  , "      return (Mk" ++ typeName ++ " fptr3)"
  , ""
  , "{-# NOINLINE binaryMultiMSM #-}"
  , "-- | Multiple binary MSM-s with binary coefficients,"
  , "-- and the curve points in affine coordinates"
  , "-- "
  , "-- > binaryMultiMSM :: [FlatArray Bit] -> FlatArray Affine.G1 -> FlatArray G1"
  , "-- "
  , "-- This can be more efficient (up to 2x or more), based on the number of coefficient arrays - "
  , "-- the suggested minimum is 32 - than calling 'msmBinary' multiple times"
  , "-- "
  , "-- Note: it is assumed that all the coefficient arrays have the same length!"
  , "binaryMultiMSM :: [FlatArray L.Bit] -> FlatArray " ++ hsModule hs_path_affine ++ "." ++ typeName ++ " -> FlatArray " ++ typeName
  , "binaryMultiMSM flatarrs (MkFlatArray n2 fptr2)"
  , "  | n1 /= n2   = error \"binaryMultiMSM: incompatible array dimensions\""
  , "  | otherwise  = unsafePerformIO $ do"
  , "      fptr3 <- mallocForeignPtrArray (narrs * " ++ show (3*nlimbs_p) ++ ")"
  , "      L.withFlatArrays flatarrs $ \\list -> do"                -- :: [FlatArray a] -> ([(Int, Ptr Word64)] -> IO b) -> IO b
  , "        let ptrs = map (castPtr . snd) list :: [Ptr Word8]"
  , "        withArray ptrs $ \\ptr_ptrs -> do"
  , "          withForeignPtr fptr2 $ \\ptr2 -> do"
  , "            withForeignPtr fptr3 $ \\ptr3 -> do"
  , "              c_" ++ prefix ++ "multi_MSM_binary_coeff_" ++ point_repr ++ "_out (fromIntegral narrs) (fromIntegral n1) ptr_ptrs ptr2 ptr3"
  , "      return (MkFlatArray narrs fptr3)"
  , "  where"
  , "    narrs = length flatarrs"
  , "    ns    = map L.flatArrayLength flatarrs"
  , "    n1    = case maybeAllIsEqual ns of"
  , "      Just m  -> m"
  , "      Nothing -> error \"binaryMultiMSM: incompatible coefficient array dimensions\""
  , ""
  , "{-# NOINLINE binaryMultiMSM_ #-}"
  , "-- | Multiple binary MSM-s with binary coefficients, with affine output"
  , "-- and the curve points in affine coordinates"
  , "-- "
  , "-- > binaryMultiMSM_ :: [FlatArray Bit] -> FlatArray Affine.G1 -> FlatArray Affine.G1"
  , "-- "
  , "binaryMultiMSM_ :: [FlatArray L.Bit] -> FlatArray " ++ hsModule hs_path_affine ++ "." ++ typeName ++ " -> FlatArray " ++ hsModule hs_path_affine ++ "." ++ typeName
  , "binaryMultiMSM_ flatarrs (MkFlatArray n2 fptr2)"
  , "  | n1 /= n2   = error \"binaryMultiMSM: incompatible array dimensions\""
  , "  | otherwise  = unsafePerformIO $ do"
  , "      fptr3 <- mallocForeignPtrArray (narrs * " ++ show (2*nlimbs_p) ++ ")"
  , "      L.withFlatArrays flatarrs $ \\list -> do"                -- :: [FlatArray a] -> ([(Int, Ptr Word64)] -> IO b) -> IO b
  , "        let ptrs = map (castPtr . snd) list :: [Ptr Word8]"
  , "        withArray ptrs $ \\ptr_ptrs -> do"
  , "          withForeignPtr fptr2 $ \\ptr2 -> do"
  , "            withForeignPtr fptr3 $ \\ptr3 -> do"
  , "              c_" ++ prefix ++ "multi_MSM_binary_coeff_affine_out (fromIntegral narrs) (fromIntegral n1) ptr_ptrs ptr2 ptr3"
  , "      return (MkFlatArray narrs fptr3)"
  , "  where"
  , "    narrs = length flatarrs"
  , "    ns    = map L.flatArrayLength flatarrs"
  , "    n1    = case maybeAllIsEqual ns of"
  , "      Just m  -> m"
  , "      Nothing -> error \"binaryMultiMSM_: incompatible coefficient array dimensions\""
  , ""
  ]


msmCurve :: CodeGenParams -> Code
msmCurve (CodeGenParams{..}) =
  [ "//------------------------------------------------------------------------------"
  , ""
  , "#define SIDX(b) (SUMS + (b-1)*(3*NLIMBS_P))"
  , ""
  , "// Multi-Scalar Multiplication (MSM)"
  , "// standard coefficients (NOT montgomery!)"
  , "// straightforward Pippenger bucketing method"
  , "// parametric bucket size"
  , "void " ++ prefix ++ "MSM_std_coeff_" ++ point_repr ++ "_out_variable(int npoints, const uint64_t *expos, const uint64_t *grps, uint64_t *tgt, int expo_nlimbs, int window_size) {"
  , ""
  , "  assert( (window_size > 0) && (window_size <= 64) );"
  , ""
  , "  int nwindows = (64*expo_nlimbs + window_size - 1) / window_size;"
  , "  int nbuckets = (1 << window_size);"
  , ""
  , "  " ++ prefix ++ "set_infinity(tgt);"
  , ""
  , "  // allocate memory for bucket sums"
  , "  uint64_t *SUMS = malloc( 3*8*NLIMBS_P * (nbuckets-1) );"
  , "  assert( SUMS !=0 );"
  , ""
  , "  // loop over the windows"
  , "  for(int K=nwindows-1; K >= 0; K-- ) {"
  , ""
  , "    // K-th window"
  , "    int A = K*window_size;"
  , "    int B = A + window_size;"
  , "    if (B > 64*expo_nlimbs ) { B = 64*expo_nlimbs; }"
  , ""
  , "    uint64_t mask = (1<<(B-A)) - 1;"
  , ""
  , "    int Adiv = (A >> 6);    // A / 64"
  , "    int Amod = (A & 0x3f);  // A mod 64"
  , ""
  , "    int Bdiv = Adiv;"
  , "    int Bshl = 0;"
  , "    if (((B-1)>>6) != Adiv) { "
  , "      // the window intersects qword boundary..."
  , "      Bdiv = Adiv + 1; "
  , "      Bshl = 64*Bdiv - A; "
  , "    }"
  , ""
  , "    // we could do this in constant memory, but then would have "
  , "    // to we go over the points way many (=bucket_size) times..."
  , ""
  , "    // initalize bucket sums"
  , "    for( int b=nbuckets-1; b>0; b-- ) { "
  , "      " ++ prefix ++ "set_infinity( SIDX(b) );"
  , "    }"
  , ""
  , "    // compute bucket sums"
  , "    for(int j=0; j<npoints; j++) {"
  , ""
  , "      int ofs = expo_nlimbs*j + Adiv;"
  , "      uint64_t e = (expos[ofs] >> Amod);"
  , "      if (Bdiv != Adiv) {"
  , "        e |= (expos[ofs+1] << Bshl);"
  , "      }"
  , "      e &= mask;   // bucket coeff"
  , ""
  , "      if (e>0) {"
  , "        " ++ prefix ++ "madd_" ++ point_repr ++ "_aff( SIDX(e) , grps + (2*NLIMBS_P*j) , SIDX(e) );"
  , "      }"
  , "    }"
  , ""
  , "    // compute running sums"
  , ""
  , "    uint64_t T[3*NLIMBS_P];   // cumulative sum of S-es"
  , "    uint64_t R[3*NLIMBS_P];   // running sum = sum of T-s"
  , ""
  , "    " ++ prefix ++ "set_infinity(T);"
  , "    " ++ prefix ++ "set_infinity(R);"
  , ""
  , "    for( int b=nbuckets-1; b>0; b-- ) { "
  , "      " ++ prefix ++ "add_inplace( T , SIDX(b) );"
  , "      " ++ prefix ++ "add_inplace( R , T       );"
  , "    }"
  , ""
  , "    if (!" ++ prefix ++ "is_infinity(tgt)) {    // we can skip doubling when infinity"
  , "      for(int i=0; i<window_size; i++) {"
  , "        " ++ prefix ++ "dbl_inplace(tgt);"
  , "      }"
  , "    }"
  , ""
  , "    " ++ prefix ++ "add_inplace( tgt, R );"
  , "  }"
  , ""
  , "  free(SUMS);"
  , "}"
  , ""
  , "//------------------------------------------------------------------------------"
  , ""
  , "// Multi-Scalar Multiplication (MSM)"
  , "// inputs: "
  , "//  - standard coefficients (1 field element per point)"
  , "//  - affine Montgomery points (2 field elements per point)"
  , "// output:"
  , "//  - projective ("  ++ point_repr ++ ") Montgomery point"
  , "//"
  , "void " ++ prefix ++ "MSM_std_coeff_" ++ point_repr ++ "_out(int npoints, const uint64_t *expos, const uint64_t *grps, uint64_t *tgt, int expo_nlimbs) {"
  , ""
  , "  // guess optimal window size"
  , "  int c = round( log2(npoints) - 3.5 );"
  , "  if (c < 1 ) { c = 1;  }"
  , "  if (c > 64) { c = 64; }"
  , ""
  , "  " ++ prefix ++ "MSM_std_coeff_" ++ point_repr ++ "_out_variable(npoints, expos, grps, tgt, expo_nlimbs, c);  "
  , "}"
  , ""
  , "//------------------------------------------------------------------------------"
  , ""
  , "// reference (slow) implementation of MSM"
  , "// for testing purposes"
  , "void " ++ prefix ++ "MSM_std_coeff_" ++ point_repr ++ "_out_slow_reference(int npoints, const uint64_t *expos, const uint64_t *grps, uint64_t *tgt, int expo_nlimbs) {"
  , "  uint64_t grp[3*NLIMBS_P];"
  , "  uint64_t tmp[3*NLIMBS_P];"
  , "  " ++ prefix ++ "set_infinity( tgt );"
  , "  for(int i=0; i<npoints; i++) { "
  , "    " ++ prefix ++ "from_affine( grps  + i*2*NLIMBS_P , grp );                      // convert to proj coords"
  , "    " ++ prefix ++ "scl_generic( expos + i*expo_nlimbs , grp , tmp , expo_nlimbs );     // exponentiate"
  , "    " ++ prefix ++ "add_inplace( tgt , tmp );                                     // add to the running sum"
  , "  }"
  , "}"
  , ""
  , "//------------------------------------------------------------------------------"
  , ""
  , "// Multi-Scalar Multiplication (MSM)"
  , "// inputs: "
  , "//  - Montgomery coefficients (1 field element per point)"
  , "//  - affine Montgomery points (2 field elements per point)"
  , "// output:"
  , "//  - projective ("  ++ point_repr ++ ") Montgomery point"
  , "//"
  , "void " ++ prefix ++ "MSM_mont_coeff_" ++ point_repr ++ "_out(int npoints, const uint64_t *expos, const uint64_t *grps, uint64_t *tgt, int expo_nlimbs) {"
  , "  uint64_t *std_expos = malloc(8*expo_nlimbs*npoints);"
  , "  assert( std_expos != 0);"
  , "  const uint64_t *p;"
  , "  uint64_t *q;"
  , "  p = expos;"
  , "  q = std_expos;"
  , "  for(int i=0; i<npoints; i++) {"
  , "    " ++ prefix_r ++ "to_std( p , q );"
  , "    p += expo_nlimbs;"
  , "    q += expo_nlimbs;"
  , "  }"
  , "  " ++ prefix ++ "MSM_std_coeff_" ++ point_repr ++ "_out(npoints, std_expos, grps, tgt, expo_nlimbs);"
  , "  free(std_expos);"
  , "}"
  , ""
  , "//------------------------------------------------------------------------------"
  , ""
  , "// Multi-Scalar Multiplication (MSM)"
  , "// inputs: "
  , "//  - standard coefficients (1 field element per point)"
  , "//  - affine Montgomery points (2 field elements per point)"
  , "// output:"
  , "//  - affine Montgomery point"
  , "//"
  , "void " ++ prefix ++ "MSM_std_coeff_affine_out(int npoints, const uint64_t *expos, const uint64_t *grps, uint64_t *tgt, int expo_nlimbs) {"
  , "  uint64_t tmp[3*NLIMBS_P];"
  , "  " ++ prefix ++ "MSM_std_coeff_" ++ point_repr ++ "_out(npoints, expos, grps, tmp, expo_nlimbs);"
  , "  " ++ prefix ++ "to_affine(tmp, tgt);"
  , "}"
  , ""
  , "// Multi-Scalar Multiplication (MSM)"
  , "// inputs: "
  , "//  - Montgomery coefficients (1 field element per point)"
  , "//  - affine Montgomery points (2 field elements per point)"
  , "// output:"
  , "//  - affine Montgomery point"
  , "//"
  , "void " ++ prefix ++ "MSM_mont_coeff_affine_out(int npoints, const uint64_t *expos, const uint64_t *grps, uint64_t *tgt, int expo_nlimbs) {"
  , "  uint64_t tmp[3*NLIMBS_P];"
  , "  " ++ prefix ++ "MSM_mont_coeff_" ++ point_repr ++ "_out(npoints, expos, grps, tmp, expo_nlimbs);"
  , "  " ++ prefix ++ "to_affine(tmp, tgt);"
  , "}"
  , ""
  , "//------------------------------------------------------------------------------"
  , ""
  , "// binary MSM (coefficients are all 0 or 1)"
  , "// inputs:"
  , "//  - 8 bit coefficients (assumed to be 0 or 1)"
  , "//  - affine Montgomery points (2 field elements per point)"
  , "// output:"
  , "//  - projective ("  ++ point_repr ++ ") Montgomery point"
  , "//"
  , "void " ++ prefix ++ "MSM_binary_coeff_" ++ point_repr ++ "_out(int npoints, const uint8_t *expos, const uint64_t *grps, uint64_t *tgt) {"
  , "  " ++ prefix ++ "set_infinity( tgt );"
  , "  for(int i=0; i<npoints; i++) { "
  , "    if (expos[i]) {"
  , "      // add to the running sum"
  , "      " ++ prefix ++ "madd_inplace( tgt , grps  + i*2*NLIMBS_P );"
  , "    }"
  , "  }"
  , "}"
  , ""
  , "void " ++ prefix ++ "MSM_binary_coeff_affine_out(int npoints, const uint8_t *expos, const uint64_t *grps, uint64_t *tgt) {"
  , "  uint64_t tmp[3*NLIMBS_P];"
  , "  " ++ prefix ++ "MSM_binary_coeff_" ++ point_repr ++ "_out(npoints, expos, grps, tmp);"
  , "  " ++ prefix ++ "to_affine(tmp, tgt);"
  , "}"
  , ""
  , "//--------------------------------------------------"
  , ""
  , "#define MIN(a,b)       ( ((a)<=(b)) ? (a) : (b) )"
  , "#define MAX(a,b)       ( ((a)>=(b)) ? (a) : (b) )"
  , "#define PRECALC(i)     ( precalc     + (i)*3*NLIMBS_P )"
  , "#define PRECALC_AFF(i) ( precalc_aff + (i)*2*NLIMBS_P )"
  , ""
  , "// multiple binary MSMs (coefficients are all 0 or 1)"
  , "// given an NxM matrix of boolean coefficients, we comput the MSM of each row"
  , "// with the same vector of points. This can be more efficient than calculating them"
  , "// individually by a factor of 1.1-2x-2.5x, especially when N is large, starting from say N=32"
  , "//"
  , "// inputs: "
  , "//  - N rows of 8 bit coefficients, each having length M (assumed to be 0 or 1),"
  , "//  - affine Montgomery points (2 field elements per point)"
  , "// output:"
  , "//  - N points, projective ("  ++ point_repr ++ ") Montgomery representation"
  , "//"
  , "void " ++ prefix ++ "multi_MSM_binary_coeff_" ++ point_repr ++ "_out(int nrows, int npoints, const uint8_t **coeffs, const uint64_t *grps, uint64_t *tgt) {"
  , "  "
  , "  // estimate the optimal windows size"
  , "  // based on the cost (number of addition):"
  , "  //   (M/c) * [ 2^(c-2) + N*(2^c-1)/(2^c) ]"
  , "  int c = round( 1.22 * log(nrows) - 0.5 );"
  , "  if (c< 1) { c=1;  }"
  , "  if (c>15) { c=15; }"
  , "  "  
  , "  for(int i=0; i<nrows; i++) { "
  , "    " ++ prefix ++ "set_infinity( tgt + i*3*NLIMBS_P );"
  , "  }"
  , "  "
  , "  uint64_t *precalc = (uint64_t*) malloc( (1<<c) * 8*3*NLIMBS_P );"
  , "  assert( precalc != 0 );"
  , "  " ++ prefix ++ "set_infinity( precalc );"
  , "  "
  , "  int nwindows = (npoints + c-1) / c;"
  , "  const uint64_t *gptr = grps;"
  , "  for(int k=0; k<nwindows; k++) {"
  , "  "
  , "    int A = k*c;"
  , "    int B = MIN( A+c, npoints );"
  , "    int C = B-A;"
  , "    "
  , "    // precalculate this window"
  , "    for(int j=0; j<C; j++) {"
  , "      if (j==0) {"
  , "        " ++ prefix ++ "from_affine( gptr , PRECALC(1) );"
  , "      }"
  , "      else {"
  , "        int m = (1<<j);"
  , "        for(int i=0; i<m; i++) {"
  , "          " ++ prefix ++ "madd_" ++ point_repr ++ "_aff( PRECALC(i) , gptr , PRECALC(i+m) );"
  , "        }"
  , "      }"
  , "      gptr += 2*NLIMBS_P;"
  , "    }"
  , "    "
  , "    for(int i=0; i<nrows; i++) {"
  , "      int idx = 0;"
  , "      for(int j=0; j<C; j++) {"
  , "        if (coeffs[i][A+j]) { idx |= (1 << j); }"
  , "      }"
  , "      if (idx > 0) {"
  , "        // add to the running sum"
  , "        " ++ prefix ++ "add_inplace( tgt + i*3*NLIMBS_P , PRECALC(idx) );"
  , "      }"
  , "    }"
  , "    "
  , "  }"
  , "  "
  , "  free(precalc);"
  , "}"
  , ""
  , "// affine output version"
  , "void " ++ prefix ++ "multi_MSM_binary_coeff_affine_out(int nrows, int npoints, const uint8_t **coeffs, const uint64_t *grps, uint64_t *tgt) {"
  , "  uint64_t *tmp = (uint64_t*) malloc( nrows * 8*3*NLIMBS_P );"
  , "  assert( tmp != 0 );"
  , "  " ++ prefix ++ "multi_MSM_binary_coeff_" ++ point_repr ++ "_out( nrows, npoints, coeffs, grps, tmp);"
  , "  for(int i=0; i<nrows; i++) {"
  , "    " ++ prefix ++ "to_affine( tmp + i*3*NLIMBS_P, tgt + i*2*NLIMBS_P );"
  , "  }"
  , "  free(tmp);"
  , "}"
  , ""
  , "//------------------------------------------------------------------------------"
  ]

